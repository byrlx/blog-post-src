#+OPTIONS: toc:t H:3
#+AUTHOR: Luis Xu
#+EMAIL: xuzhengchaojob@gmail.com
#+DATE: <2017-01-01 Thu 23:25>

#+TITLE: Plaid源码阅读笔记

源码地址:https://github.com/nickbutcher/plaid 

* 如何写一个compile阶段注解
主要包含两部分:
** 注解定义
1. 定义要提供的注解, Retention为"CLASS".
2. 编译打包该部分代码, 并在项目中引用
   (通过jar或gradle), 并在代码中使用注解.
   #+BEGIN_EXAMPLE
    compile 'com.jakewharton:butterknife:8.0.1'
   #+END_EXAMPLE
** 注解解析
1. 定义注解解析类, 该类继承自Processor(一般是继承自
   AbstractProcessor). 在process()函数中获取被注解的
   修饰的代码变量.
2. 打包, 并在"META-INF"目录下建立"services"目录,
   在目录下创建文件 "javax.annotation.processing.Processor", 
   文件中写入你定义的注解处理器的全包名.
   #+BEGIN_EXAMPLE
   //cat javax.annotation.processing.Processor
   butterknife.compiler.ButterKnifeProcessor
   #+END_EXAMPLE
3. 引用jar包, 有两种方法:
   + gradle插件<2.2之前, 使用 "com.neenbedankt.gradle.plugins:android-apt:1.8"
     在gradle文件中加入如下代码
     #+BEGIN_EXAMPLE
buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'
    }
}
dependencies {
...
    apt 'com.jakewharton:butterknife-compiler:8.0.1'
}
     #+END_EXAMPLE
   + 2.2之后, 使用"annotationProcessor"
     #+BEGIN_EXAMPLE
     dependencies{
       annotationProcessor 'com.jakewharton:butterknife-compiler:8.4.0'
     }
     #+END_EXAMPLE
* 工程架构
** settings.gradle
配置要包含的module,还可以定义rootProject.name
** gradle.properties
该文件可以定义一些配置, 可以在所有的gradle脚本中使用.
** checkstyle.xml
自定义的代码风格检查.
BK在[[顶层build.gradle]]的subprojects中定义了对
checkstyle.xml配置的使用, 把其与"check"任务hook
起来. 对java文件进行检查. 
#+BEGIN_EXAMPLE
  if (!project.name.equals('butterknife-gradle-plugin')) {
    apply plugin: 'checkstyle'

    task checkstyle(type: Checkstyle) {
      configFile rootProject.file('checkstyle.xml')
      source 'src/main/java'
      ignoreFailures false
      showViolations true
      include '**/*.java'

      classpath = files()
    }

    afterEvaluate {
      if (project.tasks.findByName('check')) {
        check.dependsOn('checkstyle')
      }
    }
  }
#+END_EXAMPLE
** 顶层build.gradle
做一些公共属性的配置,常见的包括
1. 各工程共享的一些配置, 例如maven地址
   插件等等. 一般使用"allprojects"或"subprojects".
   然后在里面配置属性. 
   #+BEGIN_EXAMPLE
   allprojects {
    repositories {
        mavenCentral()
        maven {
            credentials {
                username localMavenUserName
                password localMavenPasswd
            }
            url "${localMavenAddr}releases"
        }

        flatDir {
            dirs 'libs'
        }
    }
    dependencies {
      classpath 'com.android.tools.build:gradle:2.2.2'
      classpath 'gradle.plugin.com.kageiit:lintrules:1.1.2'
    }
}
   #+END_EXAMPLE
2. 配置项目中用到的依赖的别名.
   这样做的好处是集中了依赖的管理.
   #+BEGIN_EXAMPLE
ext {
  minSdkVersion = 9
  targetSdkVersion = 25
  compileSdkVersion = 25
}
def androidToolsVersion = '25.2.0'
ext.deps = [
    // Android
    android: 'com.google.android:android:4.1.1.4',
    supportCompat: "com.android.support:support-compat:$supportLibraryVersion",
   #+END_EXAMPLE
** module层build.gradle
定义本模块的各种配置.
笔记:
1. BK的BG中.
   + dependencies中针对androidTest和test细分依赖.
     #+BEGIN_EXAMPLE
  androidTestCompile deps.supportTestRunner
  testCompile deps.junit
     #+END_EXAMPLE
   + dependecies中使用"linRules"依赖lintProject.
   + 使用"apply from"引用自定义gradle脚本.
   + 使用了开源插件"com.kageiit.lintrules", 
     这样可以在dependency中使用自定义的lint模块.
     #+BEGIN_EXAMPLE
       lintRules project(':butterknife-lint')
     #+END_EXAMPLE
** 自动上传到maven
一个单独的gradle文件, 在所有的需要上传的build.gradle中引用. 
单独project的独立配置放到其module下的 gradle.properties 中.
#+BEGIN_EXAMPLE
apply plugin: 'maven'
apply plugin: 'signing'

version = VERSION_NAME
group = GROUP

def isReleaseBuild() {
  return VERSION_NAME.contains("SNAPSHOT") == false
}

def getReleaseRepositoryUrl() {
  return hasProperty('RELEASE_REPOSITORY_URL') ? RELEASE_REPOSITORY_URL
      : "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
}

def getSnapshotRepositoryUrl() {
  return hasProperty('SNAPSHOT_REPOSITORY_URL') ? SNAPSHOT_REPOSITORY_URL
      : "https://oss.sonatype.org/content/repositories/snapshots/"
}

def getRepositoryUsername() {
  return hasProperty('SONATYPE_NEXUS_USERNAME') ? SONATYPE_NEXUS_USERNAME : ""
}

def getRepositoryPassword() {
  return hasProperty('SONATYPE_NEXUS_PASSWORD') ? SONATYPE_NEXUS_PASSWORD : ""
}

afterEvaluate { project ->
  uploadArchives {
    repositories {
      mavenDeployer {
        beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }

        pom.groupId = GROUP
        pom.artifactId = POM_ARTIFACT_ID
        pom.version = VERSION_NAME

        repository(url: getReleaseRepositoryUrl()) {
          authentication(userName: getRepositoryUsername(), password: getRepositoryPassword())
        }
        snapshotRepository(url: getSnapshotRepositoryUrl()) {
          authentication(userName: getRepositoryUsername(), password: getRepositoryPassword())
        }

        pom.project {
          name POM_NAME
          packaging POM_PACKAGING
          description POM_DESCRIPTION
          url POM_URL

          scm {
            url POM_SCM_URL
            connection POM_SCM_CONNECTION
            developerConnection POM_SCM_DEV_CONNECTION
          }

          licenses {
            license {
              name POM_LICENCE_NAME
              url POM_LICENCE_URL
              distribution POM_LICENCE_DIST
            }
          }

          developers {
            developer {
              id POM_DEVELOPER_ID
              name POM_DEVELOPER_NAME
            }
          }
        }
      }
    }
  }

  signing {
    required { isReleaseBuild() && gradle.taskGraph.hasTask("uploadArchives") }
    sign configurations.archives
  }

  if (project.getPlugins().hasPlugin('com.android.application') ||
      project.getPlugins().hasPlugin('com.android.library')) {
    task install(type: Upload, dependsOn: assemble) {
      repositories.mavenInstaller {
        configuration = configurations.archives

        pom.groupId = GROUP
        pom.artifactId = POM_ARTIFACT_ID
        pom.version = VERSION_NAME

        pom.project {
          name POM_NAME
          packaging POM_PACKAGING
          description POM_DESCRIPTION
          url POM_URL

          scm {
            url POM_SCM_URL
            connection POM_SCM_CONNECTION
            developerConnection POM_SCM_DEV_CONNECTION
          }

          licenses {
            license {
              name POM_LICENCE_NAME
              url POM_LICENCE_URL
              distribution POM_LICENCE_DIST
            }
          }

          developers {
            developer {
              id POM_DEVELOPER_ID
              name POM_DEVELOPER_NAME
            }
          }
        }
      }
    }

    task androidJavadocs(type: Javadoc) {
      source = android.sourceSets.main.java.source
      classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
    }

    task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
      classifier = 'javadoc'
      from androidJavadocs.destinationDir
    }

    task androidSourcesJar(type: Jar) {
      classifier = 'sources'
      from android.sourceSets.main.java.source
    }
  } else {
    install {
      repositories.mavenInstaller {
        pom.groupId = GROUP
        pom.artifactId = POM_ARTIFACT_ID
        pom.version = VERSION_NAME

        pom.project {
          name POM_NAME
          packaging POM_PACKAGING
          description POM_DESCRIPTION
          url POM_URL

          scm {
            url POM_SCM_URL
            connection POM_SCM_CONNECTION
            developerConnection POM_SCM_DEV_CONNECTION
          }

          licenses {
            license {
              name POM_LICENCE_NAME
              url POM_LICENCE_URL
              distribution POM_LICENCE_DIST
            }
          }

          developers {
            developer {
              id POM_DEVELOPER_ID
              name POM_DEVELOPER_NAME
            }
          }
        }
      }
    }

    task sourcesJar(type: Jar, dependsOn:classes) {
      classifier = 'sources'
      from sourceSets.main.allSource
    }

    task javadocJar(type: Jar, dependsOn:javadoc) {
      classifier = 'javadoc'
      from javadoc.destinationDir
    }
  }

  if (JavaVersion.current().isJava8Compatible()) {
    allprojects {
      tasks.withType(Javadoc) {
        options.addStringOption('Xdoclint:none', '-quiet')
      }
    }
  }

  artifacts {
    if (project.getPlugins().hasPlugin('com.android.application') ||
        project.getPlugins().hasPlugin('com.android.library')) {
      archives androidSourcesJar
      archives androidJavadocsJar
    } else {
      archives sourcesJar
      archives javadocJar
    }
  }
}

#+END_EXAMPLE
#+BEGIN_EXAMPLE
POM_NAME=Butterknife Gradle Plugin
POM_ARTIFACT_ID=butterknife-gradle-plugin
POM_PACKAGING=jar
#+END_EXAMPLE
* 注解处理过程用到的系统api
1. 注解处理的入口函数是 "boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv);". 
   RoundEnviroment中包含了注解处理的信息. 
   通过调用其 ~getElementsAnnotatedWith(Class<? extends Annotation> a)~ 接口, 
   可以获取被参数注解修饰的所有元素. 该函数返回 [[Element]] 类.
** Element
Element代表了一个程序元素, 例如"包/类/方法"等.
其几个主要接口:
1. ~TypeMirror asType()~
   返回这个Element的类型, 例如基本类型/类/接口等.
2. ~ElementKind getKind();~
   返回元素的[[ElementKind]]
** TypeElement
代表一个类或一个接口
** ElementKind
详细的对Element做了分类, 包括:
PACKAGE/ENUM/CLASS/ANNOTATION_TYPE/INTERFACE/ENUM_CONSTANT/FIELD/PARAMETER/LOCAL_VARIABLE/EXCEPTION_PARAMETER/METHOD/CONSTRUCTOR/STATIC_INIT/INSTANCE_INIT/TYPE_PARAMETER/OTHER/RESOURCE_VARIABLE.
其中,
1. CLASS和ENUM被认为是class.
2. INTERFACE和ANNOTATION_TYPE被认为是interface.
* style
** 定义应用的整体style
 并在AndroidMainifest.xml的"application"中使用, 常用字段
 1. colorPrimary: is Main theme colors, 
    used for the default action bar background
 2. colorAccent: theme UI controls like checkboxes 
    and text fields
 3. statusBarColor:标题栏颜色
 4. navigationBarColor: 底部导航栏颜色
** 页面的style
 除了[[定义应用的整体style]]的属性外, 常用属性还包括:
 1. windowDrawsSystemBarBackgrounds: 状态栏是否覆盖在页面上,
    即页面的顶部和系统状态栏的顶部相同. 
    相当于代码 ~android:fitsSystemWindows="true"~
 2. windowActionBarOverlay: action bar覆盖在内容之上
 3. windowActionModeOverlay: 当触发显示一些系统上下文的action bar时
    (例如长按文字弹出的复制,粘贴对话框),
    该属性设置为true可以使得这些bar覆盖在页面之上, 
    而不是占据页面空间(使页面上/下移动)
** View的常用属性 
 1. clipToPadding: 属性定义了是否允许ViewGroup在padding中绘制,
    该值默认为true, 即不允许. 
    例如若我们给ListView设置了
    android:paddingTop="70dip" android:paddingBottom="70dip" 
    那么我们可以看到ListView的头部以上和尾部以下都占有70大小的padding,
    在滑动ListView的过程中这个padding当然是存在的.
    在padding部分是看不到ListView的item的,本质上是在这两部分没有绘制 
    我们的ListView. 
* Home
** 布局设置
*这个布局设置方法常见于FrameLayout中.*

home页的根布局是DrawerLayout, 其主页面是一个FrameLayout. 
由于设置了全屏模式. 为了避免toolbar和底部的按钮位置太靠上或靠下.
在onCreate中为这个DrawerLayout添加了一个 OnApplyWindowInsetsListener, 
并在listener中设置页面布局:
1. 获取系统顶部状态栏的位置信息, 然后将toolbar的margin设置为获取到的数据
   以实现toolbar显示在状态栏的下方.
   #+BEGIN_SRC java
                   ViewGroup.MarginLayoutParams lpToolbar = (ViewGroup.MarginLayoutParams) toolbar
                        .getLayoutParams();
                lpToolbar.topMargin += insets.getSystemWindowInsetTop();
                lpToolbar.leftMargin += insets.getSystemWindowInsetLeft();
                lpToolbar.rightMargin += insets.getSystemWindowInsetRight();
                toolbar.setLayoutParams(lpToolbar);
   #+END_SRC
2. RecyclerView也调用setPadding设置其布局参数, 保证在
   toolbar下方.
   #+BEGIN_SRC java
                grid.setPadding(
                        grid.getPaddingLeft() + insets.getSystemWindowInsetLeft(), // landscape
                        insets.getSystemWindowInsetTop()
                                + ViewUtils.getActionBarSize(HomeActivity.this),
                        grid.getPaddingRight() + insets.getSystemWindowInsetRight(), // landscape
                        grid.getPaddingBottom() + insets.getSystemWindowInsetBottom());
   #+END_SRC
3. 通过获取导航栏的位置信息布局按钮.
   #+BEGIN_SRC java
               ViewGroup.MarginLayoutParams lpFab = (ViewGroup.MarginLayoutParams) fab
                        .getLayoutParams();
                lpFab.bottomMargin += insets.getSystemWindowInsetBottom(); // portrait
                lpFab.rightMargin += insets.getSystemWindowInsetRight(); // landscape
                fab.setLayoutParams(lpFab);
   #+END_SRC
4. ViewStub占位
   使用ViewStub可以在使用的时候才初始化控件.
   #+BEGIN_SRC xml
   <ViewStub
            android:id="@+id/stub_no_connection"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:layout="@layout/no_connection"/>
   #+END_SRC
** 设置actionbar
在布局文件中定义Toolbar控件, 然后onCreate中
调用setActionBar()来设置这个控件为Actionbar.
1. 该函数后可以做一些toolbar动画. 例如标题文字
   的慢慢扩大展现.
   #+BEGIN_SRC java
    private void animateToolbar() {
        // this is gross but toolbar doesn't expose it's children to animate them :(
        View t = toolbar.getChildAt(0);
        if (t != null && t instanceof TextView) {
            TextView title = (TextView) t;

            // fade in and space out the title.  Animating the letterSpacing performs horribly so
            // fake it by setting the desired letterSpacing then animating the scaleX ¯\_(ツ)_/¯
            title.setAlpha(0f);
            title.setScaleX(0.8f);

            title.animate()
                    .alpha(1f)
                    .scaleX(1f)
                    .setStartDelay(300)
                    .setDuration(2000)
                    .setInterpolator(AnimUtils.getFastOutSlowInInterpolator(this));
        }
    }   
   #+END_SRC
2. onCreateOptionsMenu()函数中去加载menu. 
   通过设置menu项的"showAsAction"属性来决定其是否
   显示在ActionBar上.
   #+BEGIN_SRC xml
<?xml version="1.0" encoding="utf-8"?>

<!--
  Copyright 2015 Google Inc.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  -->

<menu xmlns:android="http://schemas.android.com/apk/res/android">

    <item
        android:id="@+id/menu_search"
        android:title="@string/search"
        android:icon="@drawable/ic_search_24dp"
        android:showAsAction="always" />

    <item
        android:id="@+id/menu_filter"
        android:title="@string/filter"
        android:icon="@drawable/ic_filter"
        android:showAsAction="always" />

    <item
        android:id="@+id/menu_dribbble_login"
        android:title="@string/dribbble_login"
        android:showAsAction="never" />

    <item
        android:id="@+id/menu_designer_news_login"
        android:title="@string/designer_news_login"
        android:showAsAction="never" />

    <item
        android:id="@+id/menu_about"
        android:title="@string/about"
        android:showAsAction="never" />

</menu>   
   #+END_SRC
3. onPrepareOptionsMenu()来更新menu的展示状态.
4. onOptionsItemSelected()中设置点击函数.
** 抽屉控件
通过对控件设置"layout_gravity"设置该控件为
DrawerLayout的抽屉组件.
** 数据加载和UI逻辑
主要是展示数据加载(更新)过程的UI效果.
*** 基本组件
1. DataManager用于加载数据.
2. RecyclerView用于展示数据.
3. ProgressBar用于表示正在加载.
4. ViewStub用于占位, 表示无法连接网络.
5. checkEmptyState()函数:
   + 如果RV中有数据, PB设为GONE.
   + 如果没有
     + 设置toolbar的Z轴为0.
     + 如果有网络, 设置PB可见.
6. checkConnectivity()函数检查网络
   + 如果断网, PB消失.
   + (如果没有初始化断网控件, 则调用ViewStub的inflate()函数初始化)
     展示断网动画.
*** 逻辑
1. onCreate()阶段第一次加载数据.
2. onCreate()的末尾调用checkEmptyState()函数.
   检查当前状态.
3. 每次进入onResume()都去调用checkConnectivity.
4. 网络状态发生切换时的处理.
   当网络可用时, 如果当前没有数据, 则显示PB,
   并使用DataManager加载数据.
5. 加载更多数据.
   通过实现RV的OnScrollListener来根据当前的数据显示情况, 
   然后实现加载逻辑.
   同时, RV的adapter也注册了加载监听. 当发现要加载更多数据时,
   会展示一个PB项目.
6. 上划. 
   上划会覆盖toolbar,这是通过设置了RV的另一个ScrollListener,
   + 如果当前可见的第一个item是RV的第一个item,并且
     第一个view的top等于RV的paddingTop. 则将toolbar的
     Z轴设置为0.
   + 否则设为-1, 实现覆盖效果.
